"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type AddCollateralEvent {
  id: ID!
  timestamp: Int!
  vault: Vault!
  controller: PaprController!
  account: Bytes!
  collateral: VaultCollateral!
}

input AddCollateralEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: VaultCollateral_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AddCollateralEvent_filter]
  or: [AddCollateralEvent_filter]
}

enum AddCollateralEvent_orderBy {
  id
  timestamp
  vault
  controller
  account
  collateral
}

type AllowedCollateral {
  id: ID!
  token: ERC721Token!
  controller: PaprController!
  allowed: Boolean!
}

input AllowedCollateral_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ERC721Token_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  allowed: Boolean
  allowed_not: Boolean
  allowed_in: [Boolean!]
  allowed_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AllowedCollateral_filter]
  or: [AllowedCollateral_filter]
}

enum AllowedCollateral_orderBy {
  id
  token
  controller
  allowed
}

type Auction {
  id: ID!
  startedBy: Bytes!
  endPrice: BigInt
  vault: Vault!
  nftOwner: Bytes!
  controller: PaprController!
  start: AuctionStartEvent!
  end: AuctionEndEvent
  auctionAssetID: BigInt!
  auctionAssetContract: ERC721Token!
  perPeriodDecayPercentWad: BigInt!
  secondsInPeriod: BigInt!
  startPrice: BigInt!
  paymentAsset: ERC20Token!
}

input Auction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  startedBy: Bytes
  startedBy_not: Bytes
  startedBy_in: [Bytes!]
  startedBy_not_in: [Bytes!]
  startedBy_contains: Bytes
  startedBy_not_contains: Bytes
  endPrice: BigInt
  endPrice_not: BigInt
  endPrice_gt: BigInt
  endPrice_lt: BigInt
  endPrice_gte: BigInt
  endPrice_lte: BigInt
  endPrice_in: [BigInt!]
  endPrice_not_in: [BigInt!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  nftOwner: Bytes
  nftOwner_not: Bytes
  nftOwner_in: [Bytes!]
  nftOwner_not_in: [Bytes!]
  nftOwner_contains: Bytes
  nftOwner_not_contains: Bytes
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  start: String
  start_not: String
  start_gt: String
  start_lt: String
  start_gte: String
  start_lte: String
  start_in: [String!]
  start_not_in: [String!]
  start_contains: String
  start_contains_nocase: String
  start_not_contains: String
  start_not_contains_nocase: String
  start_starts_with: String
  start_starts_with_nocase: String
  start_not_starts_with: String
  start_not_starts_with_nocase: String
  start_ends_with: String
  start_ends_with_nocase: String
  start_not_ends_with: String
  start_not_ends_with_nocase: String
  start_: AuctionStartEvent_filter
  end: String
  end_not: String
  end_gt: String
  end_lt: String
  end_gte: String
  end_lte: String
  end_in: [String!]
  end_not_in: [String!]
  end_contains: String
  end_contains_nocase: String
  end_not_contains: String
  end_not_contains_nocase: String
  end_starts_with: String
  end_starts_with_nocase: String
  end_not_starts_with: String
  end_not_starts_with_nocase: String
  end_ends_with: String
  end_ends_with_nocase: String
  end_not_ends_with: String
  end_not_ends_with_nocase: String
  end_: AuctionEndEvent_filter
  auctionAssetID: BigInt
  auctionAssetID_not: BigInt
  auctionAssetID_gt: BigInt
  auctionAssetID_lt: BigInt
  auctionAssetID_gte: BigInt
  auctionAssetID_lte: BigInt
  auctionAssetID_in: [BigInt!]
  auctionAssetID_not_in: [BigInt!]
  auctionAssetContract: String
  auctionAssetContract_not: String
  auctionAssetContract_gt: String
  auctionAssetContract_lt: String
  auctionAssetContract_gte: String
  auctionAssetContract_lte: String
  auctionAssetContract_in: [String!]
  auctionAssetContract_not_in: [String!]
  auctionAssetContract_contains: String
  auctionAssetContract_contains_nocase: String
  auctionAssetContract_not_contains: String
  auctionAssetContract_not_contains_nocase: String
  auctionAssetContract_starts_with: String
  auctionAssetContract_starts_with_nocase: String
  auctionAssetContract_not_starts_with: String
  auctionAssetContract_not_starts_with_nocase: String
  auctionAssetContract_ends_with: String
  auctionAssetContract_ends_with_nocase: String
  auctionAssetContract_not_ends_with: String
  auctionAssetContract_not_ends_with_nocase: String
  auctionAssetContract_: ERC721Token_filter
  perPeriodDecayPercentWad: BigInt
  perPeriodDecayPercentWad_not: BigInt
  perPeriodDecayPercentWad_gt: BigInt
  perPeriodDecayPercentWad_lt: BigInt
  perPeriodDecayPercentWad_gte: BigInt
  perPeriodDecayPercentWad_lte: BigInt
  perPeriodDecayPercentWad_in: [BigInt!]
  perPeriodDecayPercentWad_not_in: [BigInt!]
  secondsInPeriod: BigInt
  secondsInPeriod_not: BigInt
  secondsInPeriod_gt: BigInt
  secondsInPeriod_lt: BigInt
  secondsInPeriod_gte: BigInt
  secondsInPeriod_lte: BigInt
  secondsInPeriod_in: [BigInt!]
  secondsInPeriod_not_in: [BigInt!]
  startPrice: BigInt
  startPrice_not: BigInt
  startPrice_gt: BigInt
  startPrice_lt: BigInt
  startPrice_gte: BigInt
  startPrice_lte: BigInt
  startPrice_in: [BigInt!]
  startPrice_not_in: [BigInt!]
  paymentAsset: String
  paymentAsset_not: String
  paymentAsset_gt: String
  paymentAsset_lt: String
  paymentAsset_gte: String
  paymentAsset_lte: String
  paymentAsset_in: [String!]
  paymentAsset_not_in: [String!]
  paymentAsset_contains: String
  paymentAsset_contains_nocase: String
  paymentAsset_not_contains: String
  paymentAsset_not_contains_nocase: String
  paymentAsset_starts_with: String
  paymentAsset_starts_with_nocase: String
  paymentAsset_not_starts_with: String
  paymentAsset_not_starts_with_nocase: String
  paymentAsset_ends_with: String
  paymentAsset_ends_with_nocase: String
  paymentAsset_not_ends_with: String
  paymentAsset_not_ends_with_nocase: String
  paymentAsset_: ERC20Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Auction_filter]
  or: [Auction_filter]
}

enum Auction_orderBy {
  id
  startedBy
  endPrice
  vault
  nftOwner
  controller
  start
  end
  auctionAssetID
  auctionAssetContract
  perPeriodDecayPercentWad
  secondsInPeriod
  startPrice
  paymentAsset
}

type AuctionEndEvent {
  id: ID!
  timestamp: Int!
  auction: Auction!
  account: Bytes!
  vault: Vault!
  controller: PaprController!
}

input AuctionEndEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  auction: String
  auction_not: String
  auction_gt: String
  auction_lt: String
  auction_gte: String
  auction_lte: String
  auction_in: [String!]
  auction_not_in: [String!]
  auction_contains: String
  auction_contains_nocase: String
  auction_not_contains: String
  auction_not_contains_nocase: String
  auction_starts_with: String
  auction_starts_with_nocase: String
  auction_not_starts_with: String
  auction_not_starts_with_nocase: String
  auction_ends_with: String
  auction_ends_with_nocase: String
  auction_not_ends_with: String
  auction_not_ends_with_nocase: String
  auction_: Auction_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AuctionEndEvent_filter]
  or: [AuctionEndEvent_filter]
}

enum AuctionEndEvent_orderBy {
  id
  timestamp
  auction
  account
  vault
  controller
}

type AuctionStartEvent {
  id: ID!
  timestamp: Int!
  auction: Auction!
  account: Bytes!
  vault: Vault!
  controller: PaprController!
}

input AuctionStartEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  auction: String
  auction_not: String
  auction_gt: String
  auction_lt: String
  auction_gte: String
  auction_lte: String
  auction_in: [String!]
  auction_not_in: [String!]
  auction_contains: String
  auction_contains_nocase: String
  auction_not_contains: String
  auction_not_contains_nocase: String
  auction_starts_with: String
  auction_starts_with_nocase: String
  auction_not_starts_with: String
  auction_not_starts_with_nocase: String
  auction_ends_with: String
  auction_ends_with_nocase: String
  auction_not_ends_with: String
  auction_not_ends_with_nocase: String
  auction_: Auction_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AuctionStartEvent_filter]
  or: [AuctionStartEvent_filter]
}

enum AuctionStartEvent_orderBy {
  id
  timestamp
  auction
  account
  vault
  controller
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type CollateralAllowedChangeEvent {
  id: ID!
  timestamp: Int!
  collateralAddress: Bytes!
  controller: PaprController!
  allowed: Boolean!
}

input CollateralAllowedChangeEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  collateralAddress: Bytes
  collateralAddress_not: Bytes
  collateralAddress_in: [Bytes!]
  collateralAddress_not_in: [Bytes!]
  collateralAddress_contains: Bytes
  collateralAddress_not_contains: Bytes
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  allowed: Boolean
  allowed_not: Boolean
  allowed_in: [Boolean!]
  allowed_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralAllowedChangeEvent_filter]
  or: [CollateralAllowedChangeEvent_filter]
}

enum CollateralAllowedChangeEvent_orderBy {
  id
  timestamp
  collateralAddress
  controller
  allowed
}

type DebtDecreasedEvent {
  id: ID!
  timestamp: Int!
  vault: Vault!
  controller: PaprController!
  account: Bytes!
  amount: BigInt!
}

input DebtDecreasedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DebtDecreasedEvent_filter]
  or: [DebtDecreasedEvent_filter]
}

enum DebtDecreasedEvent_orderBy {
  id
  timestamp
  vault
  controller
  account
  amount
}

type DebtIncreasedEvent {
  id: ID!
  timestamp: Int!
  vault: Vault!
  controller: PaprController!
  account: Bytes!
  amount: BigInt!
}

input DebtIncreasedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DebtIncreasedEvent_filter]
  or: [DebtIncreasedEvent_filter]
}

enum DebtIncreasedEvent_orderBy {
  id
  timestamp
  vault
  controller
  account
  amount
}

type ERC20Token {
  id: ID!
  symbol: String!
  name: String!
  decimals: Int!
}

input ERC20Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC20Token_filter]
  or: [ERC20Token_filter]
}

enum ERC20Token_orderBy {
  id
  symbol
  name
  decimals
}

type ERC721Token {
  id: ID!
  symbol: String!
  name: String!
}

input ERC721Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ERC721Token_filter]
  or: [ERC721Token_filter]
}

enum ERC721Token_orderBy {
  id
  symbol
  name
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PaprController {
  id: ID!
  createdAt: Int!
  poolAddress: Bytes!
  underlying: ERC20Token!
  paprToken: ERC20Token!
  token0IsUnderlying: Boolean!
  maxLTV: BigInt!
  fundingPeriod: BigInt!
  target: BigInt!
  lastUpdated: Int!
  vaults(skip: Int = 0, first: Int = 100, orderBy: Vault_orderBy, orderDirection: OrderDirection, where: Vault_filter): [Vault!]
  allowedCollateral(skip: Int = 0, first: Int = 100, orderBy: AllowedCollateral_orderBy, orderDirection: OrderDirection, where: AllowedCollateral_filter): [AllowedCollateral!]!
  targetUpdates(skip: Int = 0, first: Int = 100, orderBy: TargetUpdate_orderBy, orderDirection: OrderDirection, where: TargetUpdate_filter): [TargetUpdate!]
}

input PaprController_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAt: Int
  createdAt_not: Int
  createdAt_gt: Int
  createdAt_lt: Int
  createdAt_gte: Int
  createdAt_lte: Int
  createdAt_in: [Int!]
  createdAt_not_in: [Int!]
  poolAddress: Bytes
  poolAddress_not: Bytes
  poolAddress_in: [Bytes!]
  poolAddress_not_in: [Bytes!]
  poolAddress_contains: Bytes
  poolAddress_not_contains: Bytes
  underlying: String
  underlying_not: String
  underlying_gt: String
  underlying_lt: String
  underlying_gte: String
  underlying_lte: String
  underlying_in: [String!]
  underlying_not_in: [String!]
  underlying_contains: String
  underlying_contains_nocase: String
  underlying_not_contains: String
  underlying_not_contains_nocase: String
  underlying_starts_with: String
  underlying_starts_with_nocase: String
  underlying_not_starts_with: String
  underlying_not_starts_with_nocase: String
  underlying_ends_with: String
  underlying_ends_with_nocase: String
  underlying_not_ends_with: String
  underlying_not_ends_with_nocase: String
  underlying_: ERC20Token_filter
  paprToken: String
  paprToken_not: String
  paprToken_gt: String
  paprToken_lt: String
  paprToken_gte: String
  paprToken_lte: String
  paprToken_in: [String!]
  paprToken_not_in: [String!]
  paprToken_contains: String
  paprToken_contains_nocase: String
  paprToken_not_contains: String
  paprToken_not_contains_nocase: String
  paprToken_starts_with: String
  paprToken_starts_with_nocase: String
  paprToken_not_starts_with: String
  paprToken_not_starts_with_nocase: String
  paprToken_ends_with: String
  paprToken_ends_with_nocase: String
  paprToken_not_ends_with: String
  paprToken_not_ends_with_nocase: String
  paprToken_: ERC20Token_filter
  token0IsUnderlying: Boolean
  token0IsUnderlying_not: Boolean
  token0IsUnderlying_in: [Boolean!]
  token0IsUnderlying_not_in: [Boolean!]
  maxLTV: BigInt
  maxLTV_not: BigInt
  maxLTV_gt: BigInt
  maxLTV_lt: BigInt
  maxLTV_gte: BigInt
  maxLTV_lte: BigInt
  maxLTV_in: [BigInt!]
  maxLTV_not_in: [BigInt!]
  fundingPeriod: BigInt
  fundingPeriod_not: BigInt
  fundingPeriod_gt: BigInt
  fundingPeriod_lt: BigInt
  fundingPeriod_gte: BigInt
  fundingPeriod_lte: BigInt
  fundingPeriod_in: [BigInt!]
  fundingPeriod_not_in: [BigInt!]
  target: BigInt
  target_not: BigInt
  target_gt: BigInt
  target_lt: BigInt
  target_gte: BigInt
  target_lte: BigInt
  target_in: [BigInt!]
  target_not_in: [BigInt!]
  lastUpdated: Int
  lastUpdated_not: Int
  lastUpdated_gt: Int
  lastUpdated_lt: Int
  lastUpdated_gte: Int
  lastUpdated_lte: Int
  lastUpdated_in: [Int!]
  lastUpdated_not_in: [Int!]
  vaults_: Vault_filter
  allowedCollateral_: AllowedCollateral_filter
  targetUpdates_: TargetUpdate_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PaprController_filter]
  or: [PaprController_filter]
}

enum PaprController_orderBy {
  id
  createdAt
  poolAddress
  underlying
  paprToken
  token0IsUnderlying
  maxLTV
  fundingPeriod
  target
  lastUpdated
  vaults
  allowedCollateral
  targetUpdates
}

type Query {
  paprController(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PaprController
  paprControllers(
    skip: Int = 0
    first: Int = 100
    orderBy: PaprController_orderBy
    orderDirection: OrderDirection
    where: PaprController_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PaprController!]!
  vault(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  targetUpdate(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TargetUpdate
  targetUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: TargetUpdate_orderBy
    orderDirection: OrderDirection
    where: TargetUpdate_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TargetUpdate!]!
  targetHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TargetHourData
  targetHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: TargetHourData_orderBy
    orderDirection: OrderDirection
    where: TargetHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TargetHourData!]!
  vaultCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultCollateral
  vaultCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultCollateral_orderBy
    orderDirection: OrderDirection
    where: VaultCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultCollateral!]!
  erc20Token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Token
  erc20Tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Token_orderBy
    orderDirection: OrderDirection
    where: ERC20Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Token!]!
  erc721Token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC721Token
  erc721Tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC721Token_orderBy
    orderDirection: OrderDirection
    where: ERC721Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC721Token!]!
  allowedCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllowedCollateral
  allowedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: AllowedCollateral_orderBy
    orderDirection: OrderDirection
    where: AllowedCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllowedCollateral!]!
  addCollateralEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddCollateralEvent
  addCollateralEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AddCollateralEvent_orderBy
    orderDirection: OrderDirection
    where: AddCollateralEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddCollateralEvent!]!
  removeCollateralEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCollateralEvent
  removeCollateralEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveCollateralEvent_orderBy
    orderDirection: OrderDirection
    where: RemoveCollateralEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveCollateralEvent!]!
  debtIncreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtIncreasedEvent
  debtIncreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DebtIncreasedEvent_orderBy
    orderDirection: OrderDirection
    where: DebtIncreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DebtIncreasedEvent!]!
  debtDecreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtDecreasedEvent
  debtDecreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DebtDecreasedEvent_orderBy
    orderDirection: OrderDirection
    where: DebtDecreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DebtDecreasedEvent!]!
  auction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Auction
  auctions(
    skip: Int = 0
    first: Int = 100
    orderBy: Auction_orderBy
    orderDirection: OrderDirection
    where: Auction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Auction!]!
  auctionStartEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionStartEvent
  auctionStartEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionStartEvent_orderBy
    orderDirection: OrderDirection
    where: AuctionStartEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionStartEvent!]!
  auctionEndEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionEndEvent
  auctionEndEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionEndEvent_orderBy
    orderDirection: OrderDirection
    where: AuctionEndEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionEndEvent!]!
  collateralAllowedChangeEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralAllowedChangeEvent
  collateralAllowedChangeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralAllowedChangeEvent_orderBy
    orderDirection: OrderDirection
    where: CollateralAllowedChangeEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralAllowedChangeEvent!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RemoveCollateralEvent {
  id: ID!
  timestamp: Int!
  vault: Vault!
  controller: PaprController!
  account: Bytes!
  collateral: VaultCollateral!
}

input RemoveCollateralEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: VaultCollateral_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RemoveCollateralEvent_filter]
  or: [RemoveCollateralEvent_filter]
}

enum RemoveCollateralEvent_orderBy {
  id
  timestamp
  vault
  controller
  account
  collateral
}

type Subscription {
  paprController(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PaprController
  paprControllers(
    skip: Int = 0
    first: Int = 100
    orderBy: PaprController_orderBy
    orderDirection: OrderDirection
    where: PaprController_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PaprController!]!
  vault(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Vault
  vaults(
    skip: Int = 0
    first: Int = 100
    orderBy: Vault_orderBy
    orderDirection: OrderDirection
    where: Vault_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Vault!]!
  targetUpdate(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TargetUpdate
  targetUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: TargetUpdate_orderBy
    orderDirection: OrderDirection
    where: TargetUpdate_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TargetUpdate!]!
  targetHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TargetHourData
  targetHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: TargetHourData_orderBy
    orderDirection: OrderDirection
    where: TargetHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TargetHourData!]!
  vaultCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VaultCollateral
  vaultCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: VaultCollateral_orderBy
    orderDirection: OrderDirection
    where: VaultCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [VaultCollateral!]!
  erc20Token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC20Token
  erc20Tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC20Token_orderBy
    orderDirection: OrderDirection
    where: ERC20Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC20Token!]!
  erc721Token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ERC721Token
  erc721Tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ERC721Token_orderBy
    orderDirection: OrderDirection
    where: ERC721Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ERC721Token!]!
  allowedCollateral(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AllowedCollateral
  allowedCollaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: AllowedCollateral_orderBy
    orderDirection: OrderDirection
    where: AllowedCollateral_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AllowedCollateral!]!
  addCollateralEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AddCollateralEvent
  addCollateralEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AddCollateralEvent_orderBy
    orderDirection: OrderDirection
    where: AddCollateralEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AddCollateralEvent!]!
  removeCollateralEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RemoveCollateralEvent
  removeCollateralEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RemoveCollateralEvent_orderBy
    orderDirection: OrderDirection
    where: RemoveCollateralEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RemoveCollateralEvent!]!
  debtIncreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtIncreasedEvent
  debtIncreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DebtIncreasedEvent_orderBy
    orderDirection: OrderDirection
    where: DebtIncreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DebtIncreasedEvent!]!
  debtDecreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DebtDecreasedEvent
  debtDecreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: DebtDecreasedEvent_orderBy
    orderDirection: OrderDirection
    where: DebtDecreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DebtDecreasedEvent!]!
  auction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Auction
  auctions(
    skip: Int = 0
    first: Int = 100
    orderBy: Auction_orderBy
    orderDirection: OrderDirection
    where: Auction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Auction!]!
  auctionStartEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionStartEvent
  auctionStartEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionStartEvent_orderBy
    orderDirection: OrderDirection
    where: AuctionStartEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionStartEvent!]!
  auctionEndEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AuctionEndEvent
  auctionEndEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AuctionEndEvent_orderBy
    orderDirection: OrderDirection
    where: AuctionEndEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AuctionEndEvent!]!
  collateralAllowedChangeEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralAllowedChangeEvent
  collateralAllowedChangeEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralAllowedChangeEvent_orderBy
    orderDirection: OrderDirection
    where: CollateralAllowedChangeEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralAllowedChangeEvent!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type TargetHourData {
  id: ID!
  periodStartUnix: Int!
  controller: PaprController!
  target: BigInt!
  numTargetUpdates: Int!
}

input TargetHourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  periodStartUnix: Int
  periodStartUnix_not: Int
  periodStartUnix_gt: Int
  periodStartUnix_lt: Int
  periodStartUnix_gte: Int
  periodStartUnix_lte: Int
  periodStartUnix_in: [Int!]
  periodStartUnix_not_in: [Int!]
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  target: BigInt
  target_not: BigInt
  target_gt: BigInt
  target_lt: BigInt
  target_gte: BigInt
  target_lte: BigInt
  target_in: [BigInt!]
  target_not_in: [BigInt!]
  numTargetUpdates: Int
  numTargetUpdates_not: Int
  numTargetUpdates_gt: Int
  numTargetUpdates_lt: Int
  numTargetUpdates_gte: Int
  numTargetUpdates_lte: Int
  numTargetUpdates_in: [Int!]
  numTargetUpdates_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TargetHourData_filter]
  or: [TargetHourData_filter]
}

enum TargetHourData_orderBy {
  id
  periodStartUnix
  controller
  target
  numTargetUpdates
}

type TargetUpdate {
  id: ID!
  timestamp: Int!
  txHash: Bytes!
  newTarget: BigInt!
  controller: PaprController!
}

input TargetUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  txHash: Bytes
  txHash_not: Bytes
  txHash_in: [Bytes!]
  txHash_not_in: [Bytes!]
  txHash_contains: Bytes
  txHash_not_contains: Bytes
  newTarget: BigInt
  newTarget_not: BigInt
  newTarget_gt: BigInt
  newTarget_lt: BigInt
  newTarget_gte: BigInt
  newTarget_lte: BigInt
  newTarget_in: [BigInt!]
  newTarget_not_in: [BigInt!]
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TargetUpdate_filter]
  or: [TargetUpdate_filter]
}

enum TargetUpdate_orderBy {
  id
  timestamp
  txHash
  newTarget
  controller
}

type Vault {
  id: ID!
  account: Bytes!
  token: ERC721Token!
  controller: PaprController!
  debt: BigInt!
  debtPerCollateral: BigInt!
  collateral(skip: Int = 0, first: Int = 100, orderBy: VaultCollateral_orderBy, orderDirection: OrderDirection, where: VaultCollateral_filter): [VaultCollateral!]!
  collateralCount: Int!
  latestAuctionStartTime: Int!
}

input Vault_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: ERC721Token_filter
  controller: String
  controller_not: String
  controller_gt: String
  controller_lt: String
  controller_gte: String
  controller_lte: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_contains: String
  controller_contains_nocase: String
  controller_not_contains: String
  controller_not_contains_nocase: String
  controller_starts_with: String
  controller_starts_with_nocase: String
  controller_not_starts_with: String
  controller_not_starts_with_nocase: String
  controller_ends_with: String
  controller_ends_with_nocase: String
  controller_not_ends_with: String
  controller_not_ends_with_nocase: String
  controller_: PaprController_filter
  debt: BigInt
  debt_not: BigInt
  debt_gt: BigInt
  debt_lt: BigInt
  debt_gte: BigInt
  debt_lte: BigInt
  debt_in: [BigInt!]
  debt_not_in: [BigInt!]
  debtPerCollateral: BigInt
  debtPerCollateral_not: BigInt
  debtPerCollateral_gt: BigInt
  debtPerCollateral_lt: BigInt
  debtPerCollateral_gte: BigInt
  debtPerCollateral_lte: BigInt
  debtPerCollateral_in: [BigInt!]
  debtPerCollateral_not_in: [BigInt!]
  collateral_: VaultCollateral_filter
  collateralCount: Int
  collateralCount_not: Int
  collateralCount_gt: Int
  collateralCount_lt: Int
  collateralCount_gte: Int
  collateralCount_lte: Int
  collateralCount_in: [Int!]
  collateralCount_not_in: [Int!]
  latestAuctionStartTime: Int
  latestAuctionStartTime_not: Int
  latestAuctionStartTime_gt: Int
  latestAuctionStartTime_lt: Int
  latestAuctionStartTime_gte: Int
  latestAuctionStartTime_lte: Int
  latestAuctionStartTime_in: [Int!]
  latestAuctionStartTime_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Vault_filter]
  or: [Vault_filter]
}

enum Vault_orderBy {
  id
  account
  token
  controller
  debt
  debtPerCollateral
  collateral
  collateralCount
  latestAuctionStartTime
}

type VaultCollateral {
  id: ID!
  tokenId: BigInt!
  vault: Vault
}

input VaultCollateral_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  tokenId: BigInt
  tokenId_not: BigInt
  tokenId_gt: BigInt
  tokenId_lt: BigInt
  tokenId_gte: BigInt
  tokenId_lte: BigInt
  tokenId_in: [BigInt!]
  tokenId_not_in: [BigInt!]
  vault: String
  vault_not: String
  vault_gt: String
  vault_lt: String
  vault_gte: String
  vault_lte: String
  vault_in: [String!]
  vault_not_in: [String!]
  vault_contains: String
  vault_contains_nocase: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_: Vault_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [VaultCollateral_filter]
  or: [VaultCollateral_filter]
}

enum VaultCollateral_orderBy {
  id
  tokenId
  vault
}

